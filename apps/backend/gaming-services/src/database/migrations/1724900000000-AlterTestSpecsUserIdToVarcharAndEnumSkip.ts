import { MigrationInterface, QueryRunner } from 'typeorm';

/**
 * Aligns the production schema with the TestSpec entity definition:
 * - userId should be varchar(36) (stores UUID from BFF) instead of int
 * - enum for choice should include 'SKIP' (even though we now reject persisting it)
 *
 * Notes:
 * 1. Adding a new value to a Postgres ENUM is irreversible in a simple DOWN migration.
 * 2. We keep the down migration best-effort (cannot remove ENUM value once added).
 */
export class AlterTestSpecsUserIdToVarcharAndEnumSkip1724900000000
  implements MigrationInterface
{
  name = 'AlterTestSpecsUserIdToVarcharAndEnumSkip1724900000000';

  public async up(queryRunner: QueryRunner): Promise<void> {
    // 1. Alter userId column type (int -> varchar(36))
    // Use USING cast to convert existing ints to text.
    await queryRunner.query(
      `ALTER TABLE "test_specs" ALTER COLUMN "userId" TYPE varchar(36) USING "userId"::varchar;`,
    );

    // 2. Ensure ENUM includes SKIP. The original enum name is auto-generated by TypeORM.
    // Discover enum type name in information_schema (commonly: "test_specs_choice_enum").
    // We will assume that naming; if customized, adjust manually.
    await queryRunner.query(
      `DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid WHERE t.typname = 'test_specs_choice_enum' AND e.enumlabel = 'SKIP') THEN ALTER TYPE "test_specs_choice_enum" ADD VALUE 'SKIP'; END IF; END $$;`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // Revert userId column to integer (best-effort). This will fail if non-numeric UUIDs exist.
    // Only execute if all current values are numeric.
    await queryRunner.query(
      `DO $$
      DECLARE v_count int;
      BEGIN
        SELECT COUNT(*) INTO v_count FROM "test_specs" WHERE "userId" !~ '^[0-9]+$';
        IF v_count = 0 THEN
          ALTER TABLE "test_specs" ALTER COLUMN "userId" TYPE int USING "userId"::int;
        END IF;
      END $$;`,
    );
    // Cannot remove 'SKIP' from enum (Postgres limitation without recreation) â€” no-op.
  }
}
